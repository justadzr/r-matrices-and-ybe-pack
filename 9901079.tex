\documentclass[12pt]{article}
\usepackage{fancyhdr}
\usepackage{fullpage}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{theorem}
\newtheorem{thm}{Theorem}[section]
\newtheorem{prop}{Proposition}[section]
\newtheorem{corr}{Corollary}[section]
\newtheorem{lemma}{Lemma}[section]
{\theorembodyfont{\rm} \newtheorem{exam}{Example}[section]
 \newtheorem{rem}{Remark}[section]}
\newtheorem{defe}{Definition}[section]
\newtheorem{conj}{Conjecture}[section]
\numberwithin{equation}{section}
\pagestyle{fancy}
\lhead{Verification of the GGS conjecture for $\mathfrak {sl}(n)$, $n
\leq 12$.}
\chead{}
\rhead{Travis Schedler}
\begin{document}
\thispagestyle{plain}
\begin{center}
{\Large Verification of the GGS conjecture for $\mathfrak{sl}(n), n
\leq 12$.}

\vskip 12 pt

{\large Travis Schedler}
\end{center}
\begin{abstract}
In the 1980's, Belavin and Drinfeld classified non-unitary solutions
of the classical Yang-Baxter equation (CYBE) for simple Lie
algebras \cite{BD}.  They proved that all such solutions fall into
finitely many continuous families and introduced combinatorial objects
to label these families, Belavin-Drinfeld triples. In 1993,
Gerstenhaber, Giaquinto, and Schack attempted to quantize such
solutions for Lie algebras $\mathfrak{sl}(n).$ As a result, they
formulated a conjecture stating that certain explicitly given elements
$R \in Mat_n(\mathbb C) \otimes Mat_n(\mathbb C)$ satisfy the quantum
Yang-Baxter equation (QYBE) and the Hecke condition \cite{GGS}.
Specifically, the conjecture assigns a family of such elements $R$ to
any Belavin-Drinfeld triple of type $A_{n-1}$.  Until recently, this
conjecture has only been known to hold for $n \leq 4$.  In 1998
Giaquinto and Hodges checked the conjecture for $n=5$ by direct
computation using {\it Mathematica} \cite{GH}.  Here we report a
computation which allowed us to check that the conjecture holds for $n
\leq 12$.  The program is included which prints an element $R$ for any
triple and checks that R satisfies the QYBE and Hecke conditions.
\end{abstract}

\section{Belavin-Drinfeld triples}

Let $(e_i), 1 \leq i \leq n,$ be a basis for $\mathbb C^n$.  Set
$\Gamma = \{e_i - e_{i+1}: 1 \leq i \leq n-1\}$.  We will use the
notation $\alpha_i \equiv e_i - e_{i+1}$.  Let $( , )$ denote the
inner product on $\mathbb C^n$ having $(e_i)$ as an orthonormal basis.

\begin{defe}
A Belavin-Drinfeld triple of type $A_{n-1}$ is a triple 
$(\tau, \Gamma_1, \Gamma_2)$ where $\Gamma_1, \Gamma_2 \subset \Gamma$
and $\tau: \Gamma_1 \rightarrow \Gamma_2$ is a bijection, satisfying
two conditions:

(a) $\forall \alpha, \beta
\in \Gamma_1$, $(\tau \alpha,\tau \beta) = (\alpha, \beta)$.

(b) $\tau$ is nilpotent: $\forall \alpha \in \Gamma_1, \exists k
\in \mathbb N$ such that $\tau^k \alpha \notin \Gamma_1$.
\end{defe}

We employ three isomorphisms of Belavin-Drinfeld triples:

a) Any triple $(\tau, \Gamma_1, \Gamma_2)$ is isomorphic to the triple
$(\tau', \Gamma'_1, \Gamma'_2)$ obtained as follows: $\Gamma'_1 =
\{\alpha_m: \alpha_{n-m} \in \Gamma_1\}$, $\tau'(\alpha_m) = \alpha_k$
where $\tau(\alpha_{n-m}) = \alpha_{n-k}$.

b) Any triple $(\tau, \Gamma_1, \Gamma_2)$ is isomorphic to the triple
$(\tau^{-1}, \Gamma_2, \Gamma_1)$.

c) The product of isomorphisms (a), (b).

Modulo these isomorphisms, we found all Belavin-Drinfeld triples for
$n \leq 13$ by computer.  The number of such triples is given below:
\vskip 12 pt

\begin{center}
\begin{tabular}{|c|c||c|c||c|c|}\hline
n & \# of triples & n & \# of triples & n & \# of triples \\ \hline
%2 & 1 &
%3 & 2 &
%4 & 4 \\
%5 & 13 &
%6 & 41 &
%7 & 161 \\
%8 & 611 &
%9 & 2490 & 
%10 & 10434 \\ \hline
2 & 1 & 6 & 41 & 10 & 10434 \\ \hline
3 & 2 & 7 & 161 & 11 & 45069 \\ \hline
4 & 4 & 8 & 611 & 12 & 201300 \\ \hline
5 & 13 & 9 & 2490 & 13 & 919479 \\ 
\hline
\end{tabular}
\end{center}

\section{The GGS conjecture}

Let $\mathfrak g = {\mathfrak sl}(n)$ be the Lie algebra of $n \times
n$ matrices of trace zero. Set $\mathfrak h \subset \mathfrak g$ to be
the subset of diagonal matrices.  Elements of $\mathbb C^n$ define
linear functions on $\mathfrak h$ by $\bigl( \sum_i \lambda_i e_i
\bigr) \bigl( \sum_i a_i e_{ii} \bigr)= \sum_i \lambda_i a_i$.  Set
$\sigma = \sum_{1 \leq i,j \leq n} e_{ij} \otimes e_{ji}$, and let $P$
be the orthogonal projection of $\sigma$ to $\mathfrak g \otimes
\mathfrak g$ with respect to the form $(X,Y) = Tr(XY)$ on
$Mat_n(\mathbb C)$.  Then, set $P^0$ to be
the projection of $P$ to $\mathfrak h \otimes \mathfrak h$.  Thus $P^0
= \sum_i \frac{n-1}{n} e_{ii} \otimes e_{ii} - \sum_{i \neq j}
\frac{1}{n} e_{ii} \otimes e_{jj}$.
 
For any Belavin-Drinfeld triple, consider the following equations:

\begin{gather} \label{r01}
r^0_{12} + r^0_{21} = P^0. \\ \label{r02} \forall \alpha \in \Gamma_1,
(\tau \alpha \otimes 1)r^0 + (1 \otimes \alpha) r^{0} = 0.
\end{gather}

Belavin and Drinfeld showed that nonunitary solutions of the CYBE
correspond to solutions of these equations.  Define $\tilde r^0 =
r^0-P^0/2$.

The GGS conjecture gives an explicit form of a matrix $R \in
Mat_n(\mathbb C) \otimes Mat_n(\mathbb C)$ for any given triple and
any given $r^0 \in \mathfrak h \otimes \mathfrak h$ satisfying
\eqref{r01}, \eqref{r02} as follows:

Set $\tilde \Gamma_1 = \{v \in \text{Span}(\Gamma_1): v = e_i - e_j, 0
\leq i < j \leq n, i \neq j\}$, and define $\tilde \Gamma_2$ similarly.
Then, extend $\tau$ to a map $\tilde \Gamma_1 \rightarrow \tilde
\Gamma_2$ so that $\tau$ is additive, i.e. $\tau(a+b) = \tau(a) +
\tau(b)$ provided $a,b,(a+b) \in \tilde \Gamma_1$.  Further, define
$\alpha \prec \beta$ if $\alpha \in \tilde \Gamma_1$ and
$\tau^k(\alpha) = \beta$, for some $k \geq 1$.  It is clear from the
conditions on $\tau$ that this means, given $\alpha = \alpha_i +
\ldots + \alpha_{i+p}$, that $\beta = \alpha_j + \ldots +
\alpha_{j+p}$, $0 \leq p \leq n-2, 1 \leq i,j \leq n, i \neq j$.
Assume $\beta = \tau^k(\alpha), k \geq 1$.  If, in this case,
$\tau^k(\alpha_i) = \alpha_{j+p}$, that is, $\tau^k$ sends the left
endpoint of $\alpha$ to the right endpoint of $\beta$, then define
$\text{sign}(\alpha,\beta) = (-1)^p$.  Otherwise, set
$\text{sign}(\alpha,\beta) = 1$.

We will use the notation $x \wedge y \equiv \frac{1}{2} (x \otimes y - y
\otimes x)$.  Furthermore, for all matrices $x \in Mat_n(\mathbb C)
\otimes Mat_n(\mathbb C)$ we will use the notation $x = \sum_{i,j,k,l}
x_{ik}^{jl} e_{ij} \otimes e_{kl}$.  Let $q$ be indeterminate and set
$\hat q \equiv q-q^{-1}$.  Finally, for any $\alpha = e_i - e_j$, set
$e_{\alpha} = e_{ij}$, and say $\alpha > 0$ if $i < j$, otherwise
$\alpha < 0$.  Now, we can define the matrix $R$ as follows:

\begin{gather} \label{ace}
a = 2 \sum_{\underset{\alpha \prec \beta}{\alpha, \beta > 0}}
\text{sign}(\alpha,\beta)\: e_{-\alpha} \wedge e_{\beta}, \quad c =
\sum_{\alpha > 0} e_{-\alpha} \wedge e_\alpha, \quad \epsilon = ac +
ca + a^2, \\ \label{tars}
\tilde a = \sum_{i,j,k,l} a_{ik}^{jl} q^{a_{ik}^{jl}
\epsilon_{ik}^{jl}}, \quad R_s = q \sum_{i} e_{ii} \otimes e_{ii} +
\sum_{i \neq j} e_{ii} \otimes e_{jj} + \hat q \sum_{i>j} e_{ij}
\otimes e_{ji}, \\ \label{r} R = q^{\tilde r^0} (R_s + \hat q \tilde a)
q^{\tilde r^0}.
\end{gather}

\begin{conj}{\bf (GGS)}  
The matrix $R$ satisfies the quantum Yang-Baxter equation, 
$R_{12} R_{13} R_{23} = R_{23} R_{13} R_{12}$, and $PR$ satisfies 
the Hecke relation, $(PR-q)(PR+q^{-1}) = 0$.
\end{conj}

\section{Checking GGS by computer}

We checked the GGS conjecture through a program written in C, which
takes as input any list of Belavin-Drinfeld triples.  For each triple,
it finds a valid $\tilde r^0$, constructs the matrix $R$, and checks
the QYBE and Hecke conditions.  Following is a more detailed
description of the procedure.

We will use the notation $\tau(\alpha) = 0$ if $\alpha \notin \tilde
\Gamma_1$.  Given a triple, the first step is to find an appropriate
$\tilde r^0$.  We rewrite the equations \eqref{r01}, \eqref{r02} as
follows:

\begin{gather} \label{tr01}
\tilde r^0_{12} + \tilde r^0_{21} = 0, \\ \label{tr02} \forall \alpha
\in \Gamma_1, ((\alpha - \tau \alpha) \otimes 1) \tilde r^0 =
\textstyle{\frac{1}{2}} ((\alpha + \tau \alpha) \otimes 1) P^0.
\end{gather}

As before, we view elements of $\mathbb C^n$ as linear functions on
$\mathfrak h$.  Then, it is easy to check $(\alpha_i)_{1 \leq i \leq
n-1}$ and $(\alpha_i - \tau \alpha_i)_{1 \leq i \leq n-1}$ are bases
of $\mathfrak h^*$.  Let $(g_i)$ and $(f_i)$ be dual to the bases
$(\alpha_i)$ and $(\alpha_i - \tau \alpha_i)$, respectively. Then, if
we view $\tilde r^0$ as an element of $Mat_{n-1}(\mathbb C)$ in the
basis $(f_i)$, it is clear that $\tilde r^0 = (b_{ij})$ where $b_{ij}
= \frac{1}{2} (\alpha_i + \tau \alpha_i, \alpha_j - \tau \alpha_j), i
\in \Gamma_1,$ where the inner product is the same we defined earlier
on $\mathbb C^n$, and $b_{ji} = -b_{ij}, i \notin \Gamma_1, j \in
\Gamma_1$.  Then, the free components of $\tilde r^0$ are those
$b_{ij}$ with $i,j \notin \Gamma_1, i < j$, which determine those
$b_{ij}, i,j \notin \Gamma_1, i > j$ since $\tilde r^0$ is
skew-symmetric.  Thus, the dimension of the space of all valid $\tilde
r^0$ is $n-m-1 \choose 2$.

The computer program merely chooses $b_{ij} = 0$ whenever $i,j \notin
\Gamma_1$.  It is known that it is sufficient to consider one element
from the family of possible $\tilde r^0$ in verifying the GGS
conjecture.  Namely, this follows from

\begin{prop} 
If $R$ of the form \eqref{r} satisfies the QYBE and PR satisfies the
Hecke relation for a given $\tilde r^0$ satisfying \eqref{tr01},
\eqref{tr02}, then for any other solution $\tilde r^0 + r'$ of
\eqref{tr01}, \eqref{tr02}, $q^{r'} R q^{r'}$ also satisfies the QYBE
and $P q^{r'} R q^{r'}$ satisfies the Hecke relation.
\end{prop}

{\it Proof.}  It is clear that $P q^{r'} R q^{r'} = q^{r'_{21}} PR
q^{r'}$. Since $r'_{21} = -r'$ by \eqref{tr01}, the Hecke relation may
be rewritten as $q^{-r'} (PR - q) (PR + q^{-1}) q^{r'} = 0$, which is
true iff $PR$ satisfies the Hecke relation.

To see that $q^{r'} R q^{r'}$ satisfies the QYBE, we take the
following steps.  By \eqref{tr02},
\begin{equation} \label{rp1}
((\alpha - \tau \alpha) \otimes 1) r' = 0.
\end{equation}
Suppose that $r' = \sum_i a_i \otimes b_i$ where the $b_i$ are
linearly independent. By \eqref{rp1}, we know that $\alpha(a_i) =
\beta(a_i)$ whenever $\alpha \prec \beta$.  Then we consider the
commutator $[a_i \otimes 1 + 1 \otimes a_i, R]$ = $[a_i \otimes 1 + 1
\otimes a_i, q^{\tilde r^0}R_s q^{\tilde r^0} + \hat q q^{\tilde r^0}
\tilde a q^{\tilde r^0}]$.  First note that $[a_i, e_{\alpha}] =
\alpha(a_i) e_\alpha$ for any $a_i \in \mathfrak h$.  Then, it is
clear $[a_i \otimes 1 + 1 \otimes a_i, q^{\tilde r^0} R_s q^{\tilde
r^0}] = [a_i \otimes 1 + 1 \otimes a_i, \sum_{i > j} d_{ij} e_{ij}
\otimes e_{ji}] = \sum_{i > j} d_{ij} (\alpha(a_i)-\alpha(a_i)) e_{ij}
\otimes e_{ji} = 0$ for the appropriate coefficients $d_{ij}$.  Now,
we see that
\begin{multline*}
[a_i \otimes 1 + 1\otimes a_i, q^{\tilde r^0} \tilde a q^{\tilde r^0}]
= [a_i \otimes 1 + 1 \otimes a_i, \sum_{\alpha, \beta > 0, \alpha
\prec \beta} (f_{\alpha,\beta} e_{-\alpha} \otimes e_{\beta} +
g_{\alpha, \beta} e_{\beta} \otimes e_{-\alpha})] \\ = \sum_{\alpha,
\beta > 0, \alpha \prec \beta} (\beta(a_i) - \alpha(a_i))
(f_{\alpha,\beta} e_{-\alpha} \otimes e_{\beta} + g_{\alpha, \beta}
e_{\beta} \otimes e_{-\alpha}) = 0.
\end{multline*}

This implies that $r' \in \Lambda^2 K$ where $K$ is the space of
symmetries of $R$, that is, $K = \{ x \in Mat_{n}(\mathbb C): [1
\otimes x + x \otimes 1, R] = 0\}$.  Furthermore, it is well-known and
easy to check that if $x \in \Lambda^2 K$ and $R$ satisfies the QYBE,
then $e^x R e^x$ also satisfies the QYBE.  Thus, in our case, we have
proved that $q^{r'} R q^{r'}$ satisfies the QYBE.  The proposition is
proved.$\quad\square$

Now, given the chosen $\tilde r^0$ in the basis $(f_i)$, the computer
program changes bases to $(g_i)$.  This is accomplished via the
transformation $[\tilde r^0]_{(g_i)} =
([(1-\tau)]_{(\alpha_i)}^{-1})^{T} [\tilde r^0]_{(f_i)}
[(1-\tau)]_{(\alpha_i)}^{-1}$ where $(1-\tau)$ is considered to be a
linear transformation on $\mathfrak h^*$, with $(1-\tau)\alpha_i =
\alpha_i - \tau \alpha_i$. Denote this new matrix by $(b'_{ij})$.

Then, the computer program obtains the matrix $[\tilde r^0]_{(e_{ii})}
\in Mat_n(\mathbb C)$ from this matrix by two quick transformations.
First it finds the intermediate matrix $(b''_{ij}) = [\tilde
r^0]_{(e_{ii}),(g_i)} \in Mat_{n \times (n-1)}(\mathbb C)$ by
$b''_{i1} = \frac{1}{n} ((n-1)b'_{i1} + (n-2)b'_{i2} + \ldots +
b'_{i,n-1})$, and the other terms follow easily.  The same technique
on the other side finally gives $[\tilde r^0]_{(e_{ii})}$.

Once $\tilde r^0$ is obtained, the computer constructs the matrix $R
\in Mat_n(\mathbb C) \otimes Mat_n(\mathbb C)$ in the basis $e_{ij}
\otimes e_{kl}, 1 \leq i,j,k,l \leq n$.  First it computes $a$, $c$,
and $\epsilon$ by \eqref{ace}.  Then, formulas \eqref{tars}, \eqref{r}
are implemented for each entry separately.  Elements $x \in
Mat_n(\mathbb C) \otimes Mat_n(\mathbb C)$ are implemented as
3-dimensional arrays $(x_{ik}^j)$, since all matrices presented in the
GGS conjecture take the form $\sum_{i,j,k} x_{ik}^j e_{ij} \otimes
e_{k,i+k-j}$.  Polynomials in $q$ are implemented as structures
containing two arrays of integers, one for positive and one for
negative powers of $q$.  The sizes of the arrays are determined in the
input of the program.

The computer checks the QYBE and Hecke conditions in the following
manner.  For the QYBE condition, the corresponding entries of $R_{12}
R_{13} R_{23}$ and $R_{23} R_{13} R_{23}$ are computed and compared
individually; both take the form
$\sum_{i,j,k,l,m} d_{ikm}^{jl} e_{ij} \otimes e_{kl} \otimes
e_{m,i+k+m-j-l}$.  The same method is applied to the Hecke condition
with matrices $\sum_{i,j,k} d_{ik}^j e_{ij} \otimes
e_{k,i+k-j}$.  Explicitly, if $R = \sum_{i,j,k} r_{ik}^j e_{ij} \otimes
e_{k,i+k-j}$, the QYBE and Hecke conditions become, respectively:

\begin{gather}
\sum_p r_{ik}^{k+i-p} r_{k+i-p,m}^j r_{p,m+k+i-p-j}^l = \sum_p
r_{km}^p r_{i,m+k-p}^{j+l-p} r_{j+l-p,p}^j, \forall i,j,k,l,m. \\
\sum_l r_{ki}^l r_{k+i-l,l}^j = \delta_{ij} + \hat q r_{ki}^j, \forall
i,j,k.
\end{gather}

Then, the computer prints the matrices $\tilde r^0$ and $R$ and
reports whether or not the conditions passed.  

After generating all Belavin-Drinfeld triples for $n \leq 13$ as
described in the previous section, all tests were performed on each
triple where $n \leq 12$ with this procedure, all of which passed.
Thus, by application of the previous proposition, we have the
following result:

\begin{prop}  
The GGS conjecture is true for Lie algebras $\mathfrak{sl}(n)$ with $n
\leq 10$.
\end{prop}

The computer program is included with this paper, with instructions on
usage included with the program itself.

\section{Acknowledgements}

I would like to thank Pavel Etingof for his generous help and advice.
I would also like to thank the Harvard College Research Program for
their support.

\begin{thebibliography}{VancVanRL}

\bibitem{BD} Belavin, A.A. and Drinfeld, V.G.: Triangle equations and
simple Lie algebras, in: S.P.Novikov (ed.), {\it Mathematical Physics
Reviews}, Harwood, New York, 1984, 93-166.

\bibitem{GGS} Gerstenhaber, M., Giaquinto, A., and Schack, S.D.:
Construction of quantum groups from Belavin-Drinfeld infinitesimals,
in: A. Joseph and S. Shnider (eds), {\it Quantum Deformations of
Algebras and their Representations,} Israel Math. Conf. Series 7,
Bar-Ilan Univ., Ramat Gan, 1993, pp. 45-64.

\bibitem{GH} Giaquinto, A. and Hodges, T.: Nonstandard solutions of
the Yang-Baxter equation, {\it Letters in Mathematical Physics} {\bf
44} (1998), 67-75.

\end{thebibliography}
\end{document}
The program follows (ggstest2.c):
--------------------------------
/*  ggstest2.c  GGS test, version 2
    Copyright 1999 by Travis Schedler, <schedler@fas.harvard.edu>.  
    All rights reserved.
    This program is licensed under the GNU General Public License.
    Verbatim distribution is encouraged.  This program has no warranty.


    Instructions on usage: Create a text file called "triples" in the
    directory with this program.  Once the file is created, the program 
    should be compiled and run with no arguments, with output given in
    standard output.  The format of the output is described in the
    output section.  The file "triples" should be formatted as follows:

    Note: the commas and periods below are essential!  a_i, b_i, etc. 
    are to be filled in by natural numbers.

    Line 1:  a_1,a_2,...,a_k.
    Line 2:  b_1,b_2,...,b_l.
            .
            .
            .

    Each line contains one triple.  In this case, the first triple is in 
    sl(k-1), the second sl(l-1).  We must have k,l < n.  The notation is 
    this: a_i indicates \tau(\alpha_i) = \alpha_{a_i}, unless a_i = 0, 
    in which case \alpha_i is not in \Gamma_1.

    The commas and periods are essential and must be as indicated!
    That is, commas separate n,d and elements of a given triple, and
    periods separate n,d and the triples from each other.  The line
    breaks need not be as indicated, however.
  


    Example "triples" file:

    2,3,4,0.
    3,4,0,1.

    This file indicates n <= 5, and 100 are enough terms in all
    polynomials.  The first line is the Cremmer-Gervais triple,
    \alpha_1 -> \alpha_2, \alpha_2 -> \alpha_3, \alpha_3 ->
    \alpha_4. So \alpha_4 is not in \Gamma_1 in this case.  The second
    line is the "generalized" Cremmer-Gervais triple, \alpha_1 ->
    \alpha_3, \alpha_2 -> \alpha_4, \alpha_4 -> \alpha_1.  Here,
    \alpha_3 is not in \Gamma_1.

    
    Instructions on interpreting the output: The output is given to
    the standard output.  First, the program describes the triple it
    has been fed, in a manner such as 1 -> 2, 2 -> 3, which describes
    \tau(\alpha_1) = \alpha_2; \tau(\alpha_2) = \alpha_3.  Then, the
    program prints the \tilde r^0 and R matrices.  These are printed
    in a sequence of k matrices, each k x k, for the space sl(k).  The
    i-th matrix is indexed by j and k, and prints the entries a_{ik}^j
    e_{ij} \otimes e_{k,i+k-j}.  Thus, the k-th entry on the j-th line
    of the i-th matrix is a_{ik}^j e_{ij} \otimes e_{k,i+k-j}.  For
    \tilde r^0, the numbers should all be divided by the given
    denominator, and for R, the exponents of q should all be divided
    by the given denominator.


    Notes on compilation: I recommend using gcc; I always have good
    experience with the -O2 option.  I have only tested this program
    with gcc, on x86, UltraSparc, and R4600 environments running
    Linux 2.0.x, SunOS 5.6, and IRIX 6.2, respectively.


    If, for some reason, memory is a problem for you and you would like
    a version that does not store all of R in memory at one time, let me
    know.  Send any other comments or requests to me as well.
    Good luck with the program!  
*/

#include <stdio.h>
#include <stdlib.h>

#define dm 20
#define dmp 500

struct poly {
int posdeg;
int negdeg;
int pos[dmp];
int neg[dmp];
int con;
};

struct sp {
int c;
int a;
int b;
};

int rot[dm][dm], a[dm][dm][dm], c[dm][dm][dm], eps[dm][dm][dm];
struct sp r[dm][dm][dm];


int gcd(int a, int b) {
  int temp = abs(a), temp2 = abs(b), done;
  if(temp == 1 || temp2 == 1) done = 1;
  else if(temp == 0 || temp2 == 0) done = temp+temp2;
  while(temp > 1 && temp2 > 1) {
    temp = temp % temp2;
    if(temp == 1) done = 1;
    else if(temp == 0) done = temp2;
    else {
      temp2 = temp2 % temp;
      if(temp2 == 1) done = 1;
      else if(temp2 == 0) done = temp;
    }
  }
  return(done);
}

int gcdm(int mat[dm][dm], 
		      int new[dm][dm], int size, 
		      int factor) {
  int temp = abs(mat[0][0]), ret, count, count2;
  for(count = 0; count < size && temp != 1 ; count++) {
    for(count2 = 0; count2 < size-1 && temp != 1; count2++)
      temp = gcd(temp, mat[count][count2+1]);
    if(count < size-1) temp = gcd(temp, mat[count+1][0]);
  }
  temp = gcd(temp, factor);
  ret = factor/temp;
  for(count = 0; count < size; count++) {
    for(count2 = 0; count2 < size; count2++) {
      new[count][count2] = mat[count][count2]/temp;
    }
  }
  return(ret);
}

void setupt(int tau[dm], int iti[dm][dm], 
	    int sg) {
  int count, count2;
  for(count = 0; count < sg; count++) {
    for(count2 = 0; count2 < sg; count2++) {
      iti[count][count2]=0;
    }
  }
  for(count = 0; count < sg; count++) {
    count2 = count;
    while(count2 != sg) {
      iti[count2][count]++;
      count2 = tau[count2];
    }
  }
}

int adp(int k, int l, 
		     int sg) {
  int ans;
  if(k == sg || l == sg) ans = 0;
  else if(abs(k-l)==1) ans = -1;
  else if(k==l) ans = 2;
  else ans = 0;
  return(ans);
}

void setupb(int tau[dm], int b[dm][dm], 
	    int sg) {
  int count, count2;
  for(count = 0; count < sg; count++) {
    b[count][count]=0;
    if(tau[count] != sg) {
      for(count2 = 0; count2 < sg; count2++) {
	b[count][count2]=adp(count,count2,sg)+adp(tau[count],count2,sg)-
	  adp(count,tau[count2],sg)-adp(tau[count],tau[count2],sg);
	b[count2][count]=0-b[count][count2];
      }
    } else 
      for(count2 = 0; count2 < count; count2++)
	if(tau[count2] == sg) {b[count][count2] = 0; b[count2][count] = 0;}
    
  }
}

void altoe(int al[dm][dm], int e[dm][dm], 
	   int sg) {
  int count, count2, temp[dm][dm];
  for(count = 0; count < sg; count++) {
    temp[count][0]=0;
    for(count2 = 0; count2 < sg; count2++) {
      temp[count][0]+=(sg-count2)*al[count][count2];
    }
    for(count2 = 1; count2 < sg+1; count2++) {
      temp[count][count2]=-(sg+1)*al[count][count2-1]+temp[count][count2-1];
    }
  }
  for(count = 0; count < sg+1; count++) {
    e[0][count]=0;
    for(count2 = 0; count2 < sg; count2++) {
      e[0][count]+=(sg-count2)*temp[count2][count];
    }
    for(count2 = 1; count2 < sg+1; count2++) {
      e[count2][count]=-(sg+1)*temp[count2-1][count]+e[count2-1][count];
    }
  }
}
    

void trans(int a[dm][dm], int b[dm][dm], 
	   int size) {
  int count, count2;
  for(count = 0; count < size; count++) {
    b[count][count] = a[count][count];
    for(count2 = 0; count2 < count; count2++) {
      b[count][count2] = a[count2][count];
      b[count2][count] = a[count][count2];
    }
  }
}

void mult(int a[dm][dm], int b[dm][dm], 
	  int c[dm][dm], int size) {
  int count, count2, count3, temp;
  for(count = 0; count < size; count++) {
    for(count2 = 0; count2 < size; count2++) {
      temp = 0;
      for(count3 = 0; count3 < size; count3++) {
	temp += a[count][count3]*b[count3][count2];
      }
      c[count][count2] = temp;
    }
  }
}

void printmat(int mat[dm][dm], int size) {
  int count, count2, tempn;
  for(count = 0; count < size; count++) {
    for(count2 = 0; count2 < size; count2++) {
      if(mat[count][count2] >= 0) printf(" ");
      tempn = abs(mat[count][count2]);
      if(!tempn) tempn=1;
      while(tempn < 10000) {
	tempn *= 10;
	printf(" ",tempn);
      }
      printf("%d\t",mat[count][count2]);
    }
    printf("\n");
  }
  printf("\n");
}

void linear(int tau[dm], int sg, 
	    int *d) { 
  int open = 1, count, b[dm][dm], iti[dm][dm], 
    count2, itit[dm][dm], temp1[dm][dm], temp2[dm][dm], tempn;
  setupt(tau, iti, sg);
  trans(iti, itit, sg);
  setupb(tau, b, sg);
  mult(itit, b, temp1, sg);
  mult(temp1, iti, temp2, sg);
  altoe(temp2, temp1, sg);
  *d = gcdm(temp1, rot, sg+1, 2*(sg+1)*(sg+1));
  printf("\nrtilde, fractions of denominator %d:\n",*d);
  printmat(rot, sg+1);
}

int red(int x, int n) {
  int t = x;
  while(t < 0) t+=n;
  while(t > n-1) t-=n;
  return t;
}


void spprint(struct sp *a) {
  if((a->c) == 0) printf("0"); 
  else {
    if(abs(a->c) == 1) {
      if(a->c == -1) printf("-");
      if((a->a) == (a->b) && (a->a) == 0) printf("1");
    }
    else printf("%d", a->c);
    if(abs(a->c) > 1 && ((a->a) || (a->b))) printf(" ");
    if((a->a) != 0) printf("q^%d", a->a);
    if((a->a) && (a->b)) printf(" ");
    if((a->b) != 0) printf("qh^%d", a->b);
  }
}

void reduce(struct poly *a) {
  int count;
  for(count = a->posdeg-1; count >= 0 && a->pos[count] == 0; count--);
  a->posdeg = count+1;
  for(count = a->negdeg-1; count >= 0 && a->neg[count] == 0; count--);
  a->negdeg = count+1;
}

void polqpadd(struct poly *a, int c, int p) {
  int count;
  if(p == 0) a->con += c;
  else if(p > 0) {
    if(a->posdeg < p) {
      for(count = a->posdeg; count < p - 1; count++)
	a->pos[count] = 0;
      a->posdeg = p;
      a->pos[p - 1] = c;
    } else a->pos[p - 1] += c;
  } else {
    if(a->negdeg < (-p)) {
      for(count = a->negdeg; count < -1 - p; count++)
	a->neg[count] = 0;
      a->negdeg = (-p);
      a->neg[-1 - p] = c;
    } else a->neg[-1 - p] += c;
  }
  reduce(a);
}

void sppoladd(struct sp *a, struct poly *b, int d) {
  int count;
  if(a->c != 0) {
    if(a->b == 0) { 
      polqpadd(b, a->c, a->a);
    } else if(a->b == 1) {
      polqpadd(b, a->c, d+(a->a));
      polqpadd(b, 0-(a->c), (a->a)-d); 
    } else if(a->b == 2) {
      polqpadd(b, a->c, (d << 1)+(a->a));
      polqpadd(b, a->c, (a->a)-(d << 1)); 
      polqpadd(b, -((a->c) << 1), a->a);
    } else if(a->b == 3) {
      polqpadd(b, a->c, (3*d)+(a->a));
      polqpadd(b, -(a->c), (a->a)-(3*d)); 
      polqpadd(b, 3*(a->c), (a->a)-d);
      polqpadd(b, (-3)*(a->c), d+(a->a)); 
    }
  }
}

void zero(struct poly *a) {
  a->posdeg = 0;
  a->negdeg = 0;
  a->con = 0;
}

void spscalmult(struct sp *a, int mult) {
  if(mult == 0) {a->b = 0; a->a = 0; a->c = 0;}
  else a->c *= mult;
}

void spass(struct sp *a, struct sp *b) {
  b->a = a->a;
  b->b = a->b;
  b->c = a->c;
}

void spmult(struct sp *a, struct sp *b, struct sp *c) {
  c->c = b->c * a->c;
  c->a = b->a + a->a;
  c->b = b->b + a->b;
}

int readline(FILE *silly, int tau[dm], 
			  int *n) {
  int count, count2, good = 1, ch, temp[dm], tempn, sign;
  *n = 1;
  while(good == 1) {
    tau[*n-1] = 0;
    while(good == 1) {
      ch = fgetc(silly);
      if(ch == EOF) good = 0;
      else if(ch == ',') good = 3;
      else if(ch == '.') good = 2;      
      else if(ch>47 && ch<58) {
	tau[*n-1] *= 10;
	tau[*n-1] += ch - 48;
      }
    }
    if(good == 3) {
      tau[*n-1]--;
      (*n)++;
      good = 1;
    }
  }
  tau[*n-1]--;
  (*n)++;
  for(count = 0; count < *n - 1; count++) 
    if(tau[count] < 0) tau[count] = (*n) - 1;
  return(good);
}


void tens2mult(int a[dm][dm][dm], int b[dm][dm][dm], 
	       int c[dm][dm][dm], int size) {
  int count, count2, count3, count4;
  for(count = 0; count < size; count++) {
    for(count2 = 0; count2 < size; count2++) {
      for(count3 = 0; count3 < size; count3++) {
        c[count][count2][count3] = 0;
	for(count4 = 0; count4 < size; count4++) {
	  if(count+count3-count4 == red(count+count3-count4,size) &&
	     count+count3-count2 == red(count+count3-count2,size)) {
	    c[count][count2][count3] += a[count][count4][count3] * 
	      b[count4][count2][count+count3-count4]; 
	  }
	}
      }
    }
  }
}

void tens2add(int a[dm][dm][dm], int b[dm][dm][dm], int size) {
  int count, count2, count3;
  for(count = 0; count < size; count++) {
    for(count2 = 0; count2 < size; count2++) {
      for(count3 = 0; count3 < size; count3++) {
        b[count][count2][count3] += a[count][count2][count3];
      }
    }
  }
}

void scmult(int k, int a[dm][dm][dm], int size) {
  int count, count2, count3;
  for(count = 0; count < size; count++) {
    for(count2 = 0; count2 < size; count2++) {
      for(count3 = 0; count3 < size; count3++) {
        a[count][count2][count3] *= k;
      }
    }
  }
}

void setupa(int tau[dm], int n) {
  int count, count2, count3, temp[dm], s, f;
  for(count = 0; count < n; count++)
    for(count2 = 0; count2 < n; count2++)
      for(count3 = 0; count3 < n; count3++)
	  a[count][count2][count3]=0;
  
  for(count = 0; count < n-1; count++) {
    for(count2 = count; count2 < n-1; count2++) 
      temp[count2]=tau[count2];
    while(temp[count] < n-1) {
      for(count2 = count; count2 < n-1 && temp[count2] < n-1; count2++) {
	if(temp[count2] > temp[count]) {
	  s = temp[count]; f = temp[count2];
	  a[count2+1][count][s]++;
	  a[s][f+1][count2+1]--;
	}
	else {
	  s = temp[count2]; f = temp[count];
          if((count2 - count) % 2 == 0) {
            a[count2+1][count][s]++;
            a[s][f+1][count2+1]--;
          } else {
            a[count2+1][count][s]--;
            a[s][f+1][count2+1]++;
          }
	}
      }
      for(count2 = count; count2 < n-1 && temp[count2] < n-1; count2++)
	temp[count2]=tau[temp[count2]];      
    }
  }
}

void setupc(int n) {
  int count, count2, count3;
  for(count = 0; count < n; count++)
    for(count2 = 0; count2 < n; count2++)
      for(count3 = 0; count3 < n; count3++)
	  c[count][count2][count3]=0;
  
  for(count = 0; count < n; count++) {
    for(count2 = 0; count2 < count; count2++) {
      c[count2][count][count]--;
      c[count][count2][count2]++;
    }
  }
}

void retr(struct sp *pol, int n, int d, int i, int j, int k) {
  if(i == j) {
    pol->c = 1;
    pol->b = 0;
    if(i == k)
      pol->a = d << 1;
    else
      pol->a = rot[i][k] << 1;
  }
  else {
    pol->b = 1;
    if(j == k) {
      pol->a = 0;      
      if(i > k || i+k<j || i+k>=j+n) pol->c = 1;
      else pol->c = 0;
    } else { 
      pol->a = d*a[i][j][k]*eps[i][j][k]+rot[i][k]+rot[j][i+k-j];
      pol->c = a[i][j][k];
    }
  }
}

void setupr(int n, int d) {
  int ct1, ct2, ct3;
  printf("R, powers have denominator %d:\n",d*2);
  for(ct1 = 0; ct1 < n; ct1++) {
    for(ct2 = 0; ct2 < n; ct2++) {
      for(ct3 = 0; ct3 < n; ct3++) {
	retr(&r[ct1][ct2][ct3], n, d, ct1, ct2, ct3);
	spprint(&r[ct1][ct2][ct3]);
	if(ct3 < n-1) printf(",   ");
      }
      printf("\n");
    }
    printf("\n");
  }
}

int qybe(int n, int d, struct poly *t1, struct sp *t3, struct sp *t4) {
  int i,j,k,l,m,o,good = 1;
  for(i = 0; i < n && good; i++) 
    for(j = 0; j < n && good; j++) 
      for(k = 0; k < n && good; k++) 
        for(l = 0; l < n && good; l++) 
          for(m = 0; m < n && good; m++) { if(m+k+i-j-l == red(m+k+i-j-l,n)) {
            zero(t1);
            for(o = 0; o < n; o++) { 
	      if(k+i-o == red(k+i-o,n) && m+k+i-o-j == red(m+k+i-o-j,n)) {
	      spmult(&r[i][k+i-o][k], &r[k+i-o][j][m], t3);
	      spmult(t3, &r[o][l][m+k+i-o-j], t4);
	      sppoladd(t4, t1, d << 1);
	      }

	      if(j+l-o == red(j+l-o,n) && m+k-o == red(m+k-o,n)) {
	      spmult(&r[k][o][m], &r[i][j+l-o][m+k-o], t3);
	      spmult(t3, &r[j+l-o][j][o], t4);
	      spscalmult(t4, -1);
	      sppoladd(t4, t1, d << 1);
	      }
	    }
            if(t1->con != 0 || t1->posdeg != 0 || t1->negdeg != 0) good = 0; 
          }
	  }
  
  return good;
}

int hecke(int n, int d, struct poly *t1, struct sp *t3) {
  int i,j,k,l,m,o,good = 1;
  for(i = 0; i < n && good; i++) 
    for(j = 0; j < n && good; j++) 
      for(k = 0; k < n && good; k++) { if(k+i-j == red(k+i-j,n)) { 
	zero(t1);
	if(i == j) t1->con = -1;
	spass(&r[k][j][i], t3);
	t3->b++;
	spscalmult(t3, -1);
	sppoladd(t3, t1, d << 1);
        for(l = 0; l < n; l++) { if(k+i-l == red(k+i-l,n)) {
	  spmult(&r[k][l][i], &r[k+i-l][j][l], t3);
	  sppoladd(t3, t1, d << 1);
	}
	}
	if(t1->con != 0 || t1->posdeg != 0 || t1->negdeg != 0) good = 0;
      }
      }
  return good;
}

int main() {
  int open = 1, count, count2, tau[dm], n=0, m=0, d=0, 
    temp[dm][dm][dm], temp2[dm][dm][dm], tempn;
  struct poly tm, tm2;
  struct sp tsp, tsp2;
  FILE *silly;

  if ((silly =
       fopen("triples", "r")) == NULL) 
    fprintf(stderr, "Cannot open %s\n", "triples");  

  while(open) {
    m = 0;
    if(open = readline(silly, tau, &n)) {
      for(count = 0; count < n-1; count++) {
	if(tau[count] < n-1) {m++; printf("%d -> %d,",count+1, tau[count]+1);}
      }
      printf("m=%d,n=%d::",m,n);
      linear(tau, n-1, &d);

      tempn = gcd(2,d); 
      d /= tempn;
      tempn = 2/tempn;
      for(count = 0; count < n; count++) {
	for(count2 = 0; count2 < n; count2++) {
	  rot[count][count2] *= tempn;
	}
      }

      setupa(tau, n);
      setupc(n);

      tens2mult(a, c, temp, n);
      tens2mult(c, a, temp2, n);
      tens2add(temp2, temp, n);
      tens2mult(a, a, eps, n);
      scmult(2, eps, n);
      tens2add(temp, eps, n);

      setupr(n, d); 
      if(hecke(n, d, &tm, &tsp)) 
	printf("(hecke passed)"); else printf("(hecke failed)");
      if(qybe(n, d, &tm, &tsp, &tsp2)) 
      printf("(qybe passed)"); else printf("(qybe failed)"); 
      printf("\n\n");
    } 
  }
  fclose(silly);   
}

